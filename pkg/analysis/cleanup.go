/*
# Module: pkg/analysis/cleanup.go
Cleanup recommendations and script generation for dead code removal.

Generates actionable cleanup recommendations and shell scripts for safely
removing identified dead code.

## Linked Modules
- [./deadcode](./deadcode.go) - Dead code detection
- [../graph](../graph/graph.go) - Graph data structure

## Tags
analysis, cleanup, recommendations

## Exports
CleanupPlan, CleanupAction, GenerateCleanupPlan, GenerateScript

<!-- LinkedDoc RDF -->
@prefix code: <https://schema.codedoc.org/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

<#cleanup.go> a code:Module ;
    code:name "pkg/analysis/cleanup.go" ;
    code:description "Cleanup recommendations and script generation for dead code removal" ;
    code:language "go" ;
    code:layer "analysis" ;
    code:linksTo <./deadcode.go>, <../graph/graph.go> ;
    code:exports <#CleanupPlan>, <#CleanupAction>, <#GenerateCleanupPlan>, <#GenerateScript> ;
    code:tags "analysis", "cleanup", "recommendations" .
<!-- End LinkedDoc RDF -->
*/

package analysis

import (
	"fmt"
	"strings"
)

// CleanupPlan represents a plan for cleaning up dead code
type CleanupPlan struct {
	SafeActions   []*CleanupAction
	ReviewActions []*CleanupAction
	TotalFiles    int
	TotalLines    int
	Script        string
}

// CleanupAction represents a single cleanup action
type CleanupAction struct {
	Type           string   // "remove", "review", "refactor"
	Target         string   // File or module path
	Reason         string   // Why this action is recommended
	Confidence     float64  // Confidence level (0.0-1.0)
	Commands       []string // Shell commands to execute
	Risk           string   // "low", "medium", "high"
	EstimatedLines int      // Estimated lines to be removed
}

// GenerateCleanupPlan generates a cleanup plan from dead code analysis
func GenerateCleanupPlan(analysis *DeadCodeAnalysis) *CleanupPlan {
	plan := &CleanupPlan{
		SafeActions:   make([]*CleanupAction, 0),
		ReviewActions: make([]*CleanupAction, 0),
	}

	// Generate actions for unreferenced modules
	for _, dm := range analysis.UnreferencedModules {
		action := &CleanupAction{
			Target:         dm.Module.Path,
			Reason:         dm.Reason,
			Confidence:     dm.Confidence,
			EstimatedLines: 50, // Default estimate
		}

		if dm.SafeToRemove {
			action.Type = "remove"
			action.Risk = "low"
			action.Commands = []string{
				fmt.Sprintf("git rm %s", dm.Module.Path),
			}
			plan.SafeActions = append(plan.SafeActions, action)
			plan.TotalFiles++
			plan.TotalLines += action.EstimatedLines
		} else {
			action.Type = "review"
			action.Risk = determineRisk(dm.Confidence)
			action.Commands = []string{
				fmt.Sprintf("# Review %s for dynamic usage", dm.Module.Path),
			}
			plan.ReviewActions = append(plan.ReviewActions, action)
		}
	}

	// Generate cleanup script
	plan.Script = generateCleanupScript(plan)

	return plan
}

// GenerateScript generates a shell script for cleanup
func GenerateScript(plan *CleanupPlan) string {
	return generateCleanupScript(plan)
}

func generateCleanupScript(plan *CleanupPlan) string {
	var script strings.Builder

	script.WriteString("#!/bin/bash\n")
	script.WriteString("# Dead Code Cleanup Script\n")
	script.WriteString("# Generated by GraphFS\n")
	script.WriteString("#\n")
	script.WriteString("# This script will remove identified dead code.\n")
	script.WriteString("# Review carefully before executing!\n")
	script.WriteString("#\n\n")

	script.WriteString("set -e\n\n")

	// Add safety check
	script.WriteString("echo \"This will remove dead code files.\"\n")
	script.WriteString("echo \"Make sure you have committed all changes first!\"\n")
	script.WriteString("read -p \"Continue? (y/N): \" -n 1 -r\n")
	script.WriteString("echo\n")
	script.WriteString("if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n")
	script.WriteString("    echo \"Aborted.\"\n")
	script.WriteString("    exit 1\n")
	script.WriteString("fi\n\n")

	// Safe removals
	if len(plan.SafeActions) > 0 {
		script.WriteString("echo \"Removing dead code files...\"\n\n")

		for _, action := range plan.SafeActions {
			script.WriteString(fmt.Sprintf("# %s (confidence: %.2f)\n", action.Target, action.Confidence))
			script.WriteString(fmt.Sprintf("# Reason: %s\n", action.Reason))

			for _, cmd := range action.Commands {
				script.WriteString(fmt.Sprintf("%s\n", cmd))
			}
			script.WriteString("\n")
		}
	}

	// Files needing review
	if len(plan.ReviewActions) > 0 {
		script.WriteString("\n# Files that need manual review:\n")
		for _, action := range plan.ReviewActions {
			script.WriteString(fmt.Sprintf("# - %s (confidence: %.2f, risk: %s)\n",
				action.Target, action.Confidence, action.Risk))
			script.WriteString(fmt.Sprintf("#   Reason: %s\n", action.Reason))
		}
	}

	// Summary
	script.WriteString("\necho \"Cleanup complete!\"\n")
	script.WriteString(fmt.Sprintf("echo \"Removed %d files (~%d lines)\"\n", plan.TotalFiles, plan.TotalLines))

	if len(plan.ReviewActions) > 0 {
		script.WriteString(fmt.Sprintf("echo \"Note: %d files need manual review\"\n", len(plan.ReviewActions)))
	}

	return script.String()
}

func determineRisk(confidence float64) string {
	if confidence >= 0.8 {
		return "low"
	} else if confidence >= 0.5 {
		return "medium"
	}
	return "high"
}

// GetSafeActionCount returns the number of safe cleanup actions
func (p *CleanupPlan) GetSafeActionCount() int {
	return len(p.SafeActions)
}

// GetReviewActionCount returns the number of actions needing review
func (p *CleanupPlan) GetReviewActionCount() int {
	return len(p.ReviewActions)
}

// HasActions returns true if there are any cleanup actions
func (p *CleanupPlan) HasActions() bool {
	return len(p.SafeActions) > 0 || len(p.ReviewActions) > 0
}

// GetEstimatedImpact returns a summary of the estimated impact
func (p *CleanupPlan) GetEstimatedImpact() string {
	if !p.HasActions() {
		return "No cleanup actions needed"
	}

	return fmt.Sprintf("Remove %d files (~%d lines), review %d files",
		len(p.SafeActions), p.TotalLines, len(p.ReviewActions))
}
