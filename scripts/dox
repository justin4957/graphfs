#!/usr/bin/env bash
#
# dox - Automatic LinkedDoc/RDF documentation generator
#
# EXPERIMENTAL: This script uses pattern-based extraction to generate
# LinkedDoc/RDF documentation for codebases. The extraction is heuristic-based
# and may not perfectly capture all semantic relationships.
#
# FUTURE: This script is designed to support AI-enhanced documentation generation
# via an optional --ai flag, which would improve description quality and semantic
# understanding of module relationships. This feature is not yet implemented.
#
# Usage:
#   dox [options] [path]
#
# Options:
#   --full-dox       Process entire codebase without approval prompts
#   --dry-run        Preview changes without writing files
#   --language LANG  Specify language (default: auto-detect from extension)
#   --help           Show this help message
#
# Examples:
#   dox                          # Incremental mode with approval for each file
#   dox --full-dox              # Batch process all files
#   dox --dry-run pkg/          # Preview what would be generated
#   dox --full-dox cmd/         # Process specific directory
#

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Configuration
FULL_MODE=false
DRY_RUN=false
LANGUAGE=""
TARGET_PATH="."

# Statistics
PROCESSED=0
UPDATED=0
SKIPPED=0
FAILED=0

# Print colored output
print_color() {
    local color=$1
    shift
    echo -e "${color}${*}${NC}"
}

print_error() { print_color "$RED" "✗ $*"; }
print_success() { print_color "$GREEN" "✓ $*"; }
print_info() { print_color "$BLUE" "ℹ $*"; }
print_warning() { print_color "$YELLOW" "⚠ $*"; }

# Show help
show_help() {
    head -n 28 "$0" | tail -n 26 | sed 's/^# //' | sed 's/^#//'
    exit 0
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --full-dox)
                FULL_MODE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --language)
                LANGUAGE="$2"
                shift 2
                ;;
            --help|-h)
                show_help
                ;;
            *)
                TARGET_PATH="$1"
                shift
                ;;
        esac
    done
}

# Detect language from file extension
detect_language() {
    local file=$1
    case "${file##*.}" in
        go) echo "go" ;;
        py) echo "python" ;;
        js) echo "javascript" ;;
        ts) echo "typescript" ;;
        rs) echo "rust" ;;
        java) echo "java" ;;
        c|h) echo "c" ;;
        cpp|hpp|cc|cxx) echo "cpp" ;;
        rb) echo "ruby" ;;
        *) echo "unknown" ;;
    esac
}

# Extract layer from file path
extract_layer() {
    local filepath=$1

    # Remove leading ./ and get the parent directory name
    local dir=$(dirname "$filepath" | sed 's|^\./||')

    # For pkg/xxx or cmd/xxx, use xxx as layer
    if [[ $dir =~ ^pkg/([^/]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    elif [[ $dir =~ ^cmd/([^/]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    elif [[ $dir =~ ^internal/([^/]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        # Use the last directory component
        basename "$dir"
    fi
}

# Generate tags from file path
generate_tags() {
    local filepath=$1
    local layer=$2
    local tags=()

    # Add layer as primary tag
    [[ -n "$layer" ]] && tags+=("$layer")

    # Add path components as tags
    local dir=$(dirname "$filepath" | sed 's|^\./||')
    IFS='/' read -ra PARTS <<< "$dir"
    for part in "${PARTS[@]}"; do
        if [[ "$part" != "." && "$part" != "$layer" ]]; then
            tags+=("$part")
        fi
    done

    # Deduplicate and join
    printf '%s\n' "${tags[@]}" | sort -u | paste -sd ',' -
}

# Extract exported symbols for Go
extract_go_exports() {
    local file=$1
    local exports=()

    # Extract exported types, functions, constants
    while IFS= read -r line; do
        if [[ $line =~ ^type[[:space:]]+([A-Z][a-zA-Z0-9]*) ]]; then
            exports+=("${BASH_REMATCH[1]}")
        elif [[ $line =~ ^func[[:space:]]+([A-Z][a-zA-Z0-9]*) ]]; then
            exports+=("${BASH_REMATCH[1]}")
        elif [[ $line =~ ^const[[:space:]]+([A-Z][a-zA-Z0-9]*) ]]; then
            exports+=("${BASH_REMATCH[1]}")
        elif [[ $line =~ ^var[[:space:]]+([A-Z][a-zA-Z0-9]*) ]]; then
            exports+=("${BASH_REMATCH[1]}")
        fi
    done < "$file"

    # Deduplicate and return
    printf '%s\n' "${exports[@]}" | sort -u
}

# Extract internal dependencies for Go
extract_go_dependencies() {
    local file=$1
    local repo_root=$2
    local deps=()

    # Get the module path from go.mod
    local module_path=""
    if [[ -f "$repo_root/go.mod" ]]; then
        module_path=$(grep -m1 "^module " "$repo_root/go.mod" | awk '{print $2}')
    fi

    # Extract imports that are internal to this project
    local in_import=false
    while IFS= read -r line; do
        if [[ $line =~ ^import[[:space:]]*\( ]]; then
            in_import=true
        elif [[ $in_import == true ]]; then
            if [[ $line =~ ^\) ]]; then
                in_import=false
            elif [[ $line =~ \"([^\"]+)\" ]]; then
                local import="${BASH_REMATCH[1]}"
                # Check if it's an internal import
                if [[ -n "$module_path" && "$import" =~ ^$module_path/.+ ]]; then
                    # Convert import path to relative file path
                    local rel_path="${import#$module_path/}"
                    deps+=("$rel_path")
                fi
            fi
        elif [[ $line =~ ^import[[:space:]]+\"([^\"]+)\" ]]; then
            local import="${BASH_REMATCH[1]}"
            if [[ -n "$module_path" && "$import" =~ ^$module_path/.+ ]]; then
                local rel_path="${import#$module_path/}"
                deps+=("$rel_path")
            fi
        fi
    done < "$file"

    # Return unique dependencies
    printf '%s\n' "${deps[@]}" | sort -u
}

# Extract exported symbols for Java
extract_java_exports() {
    local file=$1
    local exports=()

    # Extract public classes, interfaces, enums, and methods
    while IFS= read -r line; do
        # Public class, interface, enum, or annotation
        if [[ $line =~ ^[[:space:]]*(public[[:space:]]+)?(abstract[[:space:]]+)?(final[[:space:]]+)?(class|interface|enum|@interface)[[:space:]]+([A-Z][a-zA-Z0-9_]*) ]]; then
            exports+=("${BASH_REMATCH[5]}")
        # Public methods (simplified - captures method name)
        elif [[ $line =~ ^[[:space:]]*public[[:space:]]+.*[[:space:]]+([a-z][a-zA-Z0-9_]*)[[:space:]]*\( ]]; then
            exports+=("${BASH_REMATCH[1]}")
        fi
    done < "$file"

    # Deduplicate and return
    printf '%s\n' "${exports[@]}" | sort -u
}

# Extract internal dependencies for Java
extract_java_dependencies() {
    local file=$1
    local repo_root=$2
    local deps=()

    # Get the package name from the file
    local file_package=$(grep -m1 "^package " "$file" | sed 's/package //;s/;.*//;s/[[:space:]]//g')

    # Detect the project root package by finding common prefix
    local project_package=""
    if [[ -n "$file_package" ]]; then
        # Use first two components of package as project identifier
        # e.g., org.apache.jena.* -> org.apache
        project_package=$(echo "$file_package" | cut -d. -f1-2)
    fi

    # Extract imports that are internal to this project
    while IFS= read -r line; do
        if [[ $line =~ ^import[[:space:]]+([a-zA-Z0-9_.]+)\; ]]; then
            local import="${BASH_REMATCH[1]}"
            # Check if it's an internal import (starts with project package)
            if [[ -n "$project_package" && "$import" =~ ^$project_package ]]; then
                # Convert package to relative path
                local rel_path=$(echo "$import" | tr '.' '/')
                deps+=("$rel_path")
            fi
        fi
    done < "$file"

    # Return unique dependencies
    printf '%s\n' "${deps[@]}" | sort -u
}

# Check if file already has LinkedDoc
has_linkeddoc() {
    local file=$1
    grep -q "<!-- LinkedDoc RDF -->" "$file" 2>/dev/null
}

# Generate description from filename
generate_description() {
    local filename=$1
    local basename=$(basename "$filename" | sed 's/\.[^.]*$//')

    # Convert snake_case or kebab-case to words
    local desc=$(echo "$basename" | sed 's/[_-]/ /g')

    # Capitalize first letter
    desc="$(tr '[:lower:]' '[:upper:]' <<< "${desc:0:1}")${desc:1}"

    echo "$desc module"
}

# Get relative path (cross-platform)
get_relative_path() {
    local target=$1
    local base=$2
    python3 -c "import os.path; print(os.path.relpath('$target', '$base'))"
}

# Generate LinkedDoc RDF for Go file
generate_go_linkeddoc() {
    local file=$1
    local repo_root=$2

    # Extract metadata
    local package_name=$(grep -m1 "^package " "$file" | awk '{print $2}')
    local relative_path=$(get_relative_path "$file" "$repo_root")
    local layer=$(extract_layer "$relative_path")
    local tags=$(generate_tags "$relative_path" "$layer")
    local description=$(generate_description "$file")

    # Extract exports
    local exports=()
    while IFS= read -r export; do
        [[ -n "$export" ]] && exports+=("$export")
    done < <(extract_go_exports "$file")

    # Extract dependencies
    local deps=()
    while IFS= read -r dep; do
        [[ -n "$dep" ]] && deps+=("$dep")
    done < <(extract_go_dependencies "$file" "$repo_root")

    # Generate module name from relative path
    local module_name="$relative_path"

    # Generate RDF
    cat <<EOF
/*
# Module: $module_name
$description

Auto-generated documentation by dox script (pattern-based extraction).
Manual review and enhancement recommended.

EOF

    # Add linked modules section if we have dependencies
    if [[ ${#deps[@]} -gt 0 ]]; then
        echo "## Linked Modules"
        for dep in "${deps[@]}"; do
            echo "- [$dep](./$dep)"
        done
        echo ""
    fi

    # Add tags
    echo "## Tags"
    echo "$tags" | sed 's/,/, /g'
    echo ""

    # Add exports
    if [[ ${#exports[@]} -gt 0 ]]; then
        echo "## Exports"
        echo "${exports[@]}" | sed 's/ /, /g'
        echo ""
    fi

    # Generate RDF
    echo "<!-- LinkedDoc RDF -->"
    echo "@prefix code: <https://schema.codedoc.org/> ."
    echo "@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ."
    echo ""

    local file_id=$(basename "$file")
    echo "<#${file_id}> a code:Module ;"
    echo "    code:name \"$module_name\" ;"
    echo "    code:description \"$description\" ;"
    echo "    code:language \"go\" ;"
    echo "    code:layer \"$layer\" ;"

    # Add links to dependencies
    if [[ ${#deps[@]} -gt 0 ]]; then
        local link_parts=()
        for dep in "${deps[@]}"; do
            link_parts+=("<../$dep>")
        done
        echo -n "    code:linksTo "
        printf '%s' "${link_parts[@]}" | sed 's/></>, </g'
        echo " ;"
    fi

    # Add exports
    if [[ ${#exports[@]} -gt 0 ]]; then
        local export_parts=()
        for export in "${exports[@]}"; do
            export_parts+=("<#${export}>")
        done
        echo -n "    code:exports "
        printf '%s' "${export_parts[@]}" | sed 's/></>, </g'
        echo " ;"
    fi

    # Add tags
    echo -n "    code:tags "
    local tag_array=(${tags//,/ })
    local quoted_tags=()
    for tag in "${tag_array[@]}"; do
        quoted_tags+=("\"$tag\"")
    done
    printf '%s' "${quoted_tags[@]}" | sed 's/" /", /g'
    echo " ."

    echo "<!-- End LinkedDoc RDF -->"
    echo "*/"
}

# Generate LinkedDoc RDF for Java file
generate_java_linkeddoc() {
    local file=$1
    local repo_root=$2

    # Extract metadata
    local package_name=$(grep -m1 "^package " "$file" | sed 's/package //;s/;.*//;s/[[:space:]]//g')
    local relative_path=$(get_relative_path "$file" "$repo_root")
    local layer=$(extract_layer "$relative_path")
    local tags=$(generate_tags "$relative_path" "$layer")
    local description=$(generate_description "$file")

    # Extract exports
    local exports=()
    while IFS= read -r export; do
        [[ -n "$export" ]] && exports+=("$export")
    done < <(extract_java_exports "$file")

    # Extract dependencies
    local deps=()
    while IFS= read -r dep; do
        [[ -n "$dep" ]] && deps+=("$dep")
    done < <(extract_java_dependencies "$file" "$repo_root")

    # Generate module name from relative path
    local module_name="$relative_path"

    # Generate RDF
    cat <<EOF
/*
# Module: $module_name
$description

Auto-generated documentation by dox script (pattern-based extraction).
Manual review and enhancement recommended.

EOF

    # Add linked modules section if we have dependencies
    if [[ ${#deps[@]} -gt 0 ]]; then
        echo "## Linked Modules"
        for dep in "${deps[@]}"; do
            echo "- [$dep](./$dep)"
        done
        echo ""
    fi

    # Add tags
    echo "## Tags"
    echo "$tags" | sed 's/,/, /g'
    echo ""

    # Add exports
    if [[ ${#exports[@]} -gt 0 ]]; then
        echo "## Exports"
        echo "${exports[@]}" | sed 's/ /, /g'
        echo ""
    fi

    # Generate RDF
    echo "<!-- LinkedDoc RDF -->"
    echo "@prefix code: <https://schema.codedoc.org/> ."
    echo "@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> ."
    echo ""

    local file_id=$(basename "$file")
    echo "<#${file_id}> a code:Module ;"
    echo "    code:name \"$module_name\" ;"
    echo "    code:description \"$description\" ;"
    echo "    code:language \"java\" ;"
    [[ -n "$package_name" ]] && echo "    code:package \"$package_name\" ;"
    echo "    code:layer \"$layer\" ;"

    # Add links to dependencies
    if [[ ${#deps[@]} -gt 0 ]]; then
        local link_parts=()
        for dep in "${deps[@]}"; do
            link_parts+=("<../$dep>")
        done
        echo -n "    code:linksTo "
        printf '%s' "${link_parts[@]}" | sed 's/></>, </g'
        echo " ;"
    fi

    # Add exports
    if [[ ${#exports[@]} -gt 0 ]]; then
        local export_parts=()
        for export in "${exports[@]}"; do
            export_parts+=("<#${export}>")
        done
        echo -n "    code:exports "
        printf '%s' "${export_parts[@]}" | sed 's/></>, </g'
        echo " ;"
    fi

    # Add tags
    echo -n "    code:tags "
    local tag_array=(${tags//,/ })
    local quoted_tags=()
    for tag in "${tag_array[@]}"; do
        quoted_tags+=("\"$tag\"")
    done
    printf '%s' "${quoted_tags[@]}" | sed 's/" /", /g'
    echo " ."

    echo "<!-- End LinkedDoc RDF -->"
    echo "*/"
}

# Insert LinkedDoc at the beginning of file
insert_linkeddoc() {
    local file=$1
    local linkeddoc=$2

    if [[ $DRY_RUN == true ]]; then
        print_info "Would insert LinkedDoc into $file"
        return 0
    fi

    # Create a temporary file
    local tmpfile=$(mktemp)

    # Write LinkedDoc followed by existing content
    echo "$linkeddoc" > "$tmpfile"
    echo "" >> "$tmpfile"
    cat "$file" >> "$tmpfile"

    # Replace original file
    mv "$tmpfile" "$file"
}

# Process a single file
process_file() {
    local file=$1
    local repo_root=$2

    ((PROCESSED++))

    # Check if already has LinkedDoc
    if has_linkeddoc "$file"; then
        print_info "Skipping $file (already has LinkedDoc)"
        ((SKIPPED++))
        return 0
    fi

    # Detect language
    local lang=${LANGUAGE:-$(detect_language "$file")}

    if [[ "$lang" != "go" && "$lang" != "java" ]]; then
        print_warning "Skipping $file (unsupported language: $lang)"
        ((SKIPPED++))
        return 0
    fi

    # Generate LinkedDoc
    print_info "Processing $file..."
    local linkeddoc=""
    if [[ "$lang" == "go" ]]; then
        linkeddoc=$(generate_go_linkeddoc "$file" "$repo_root")
    elif [[ "$lang" == "java" ]]; then
        linkeddoc=$(generate_java_linkeddoc "$file" "$repo_root")
    fi

    # Show preview in incremental mode
    if [[ $FULL_MODE == false ]]; then
        echo ""
        print_color "$CYAN" "Preview for $file:"
        echo "─────────────────────────────────────────"
        echo "$linkeddoc" | head -n 30
        if [[ $(echo "$linkeddoc" | wc -l) -gt 30 ]]; then
            echo "..."
        fi
        echo "─────────────────────────────────────────"
        echo ""

        # Ask for approval
        read -p "Apply this documentation? [y/N/q] " -n 1 -r
        echo

        if [[ $REPLY =~ ^[Qq]$ ]]; then
            print_warning "Cancelled by user"
            exit 0
        elif [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_warning "Skipped $file"
            ((SKIPPED++))
            return 0
        fi
    fi

    # Insert LinkedDoc
    if insert_linkeddoc "$file" "$linkeddoc"; then
        print_success "Updated $file"
        ((UPDATED++))
    else
        print_error "Failed to update $file"
        ((FAILED++))
        return 1
    fi
}

# Find and process all files
process_directory() {
    local path=$1
    local repo_root=$(git rev-parse --show-toplevel 2>/dev/null || pwd)

    # Find all source files
    local files=()
    if [[ -d "$path" ]]; then
        # Find Go files (excluding tests)
        while IFS= read -r file; do
            files+=("$file")
        done < <(find "$path" -type f -name "*.go" ! -name "*_test.go" | sort)

        # Find Java files (excluding tests)
        while IFS= read -r file; do
            files+=("$file")
        done < <(find "$path" -type f -name "*.java" ! -path "*/test/*" ! -path "*/tests/*" ! -name "*Test.java" | sort)
    elif [[ -f "$path" ]]; then
        files+=("$path")
    else
        print_error "Path not found: $path"
        exit 1
    fi

    if [[ ${#files[@]} -eq 0 ]]; then
        print_warning "No files found to process"
        exit 0
    fi

    print_info "Found ${#files[@]} file(s) to process"
    echo ""

    # Process each file
    for file in "${files[@]}"; do
        process_file "$file" "$repo_root" || true
    done

    # Print statistics
    echo ""
    echo "═══════════════════════════════════════════"
    print_info "Summary:"
    echo "  Processed: $PROCESSED"
    print_success "  Updated:   $UPDATED"
    print_warning "  Skipped:   $SKIPPED"
    [[ $FAILED -gt 0 ]] && print_error "  Failed:    $FAILED"
    echo "═══════════════════════════════════════════"
}

# Main
main() {
    parse_args "$@"

    # Show mode
    if [[ $FULL_MODE == true ]]; then
        print_info "Running in FULL mode (batch processing)"
    else
        print_info "Running in INCREMENTAL mode (with approval)"
    fi

    if [[ $DRY_RUN == true ]]; then
        print_warning "DRY RUN - No files will be modified"
    fi

    echo ""

    process_directory "$TARGET_PATH"
}

main "$@"
